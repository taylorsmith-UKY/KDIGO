#!/usr/bin/env python2# -*- coding: utf-8 -*-"""Created on Sun Dec  3 16:41:19 2017@author: taylorsmith"""import matplotlib.pyplot as pltimport numpy as npfrom kdigo_funcs import feature_selectionimport h5pyfrom sklearn.manifold import MDSfrom scipy.spatial.distance import squareformfrom mpl_toolkits.mplot3d import Axes3D# def network_vis(dm, ids, lbls, sizes, edge_thresh=0.2, title='', annot=''):#     mds = MDS(n_components=2, dissimilarity='precomputed', n_jobs=-1)#     sq_dist = squareform(dm[:, 2])#     fit = mds.fit(sq_dist)#     coords = fit.embedding_#     edges = np.array([dm[x, :2] for x in range(len(dm)) if dm[x, 0] < edge_thresh])#     lbl_set = set(lbls)#     for i in range(np.shape(edges)[0]):#         edges[i, 0] = np.where(ids == edges[i, 0])[0][0]#         edges[i, 1] = np.where(ids == edges[i, 1])[0][0]##     edge_trace = Scatter(#         x=[],#         y=[],#         line=Line(width=0.5, color='#888'),#         hoverinfo='none',#         mode='lines')##     for edge in edges:#         x0, y0 = coords[edge[0]]#         x1, y1 = coords[edge[1]]#         edge_trace['x'] += [x0, x1, None]#         edge_trace['y'] += [y0, y1, None]##     node_traces = []#     for i in range(len(lbl_set)):#         node_traces.append(Scattergl(#             x=[],#             y=[],#             text=[],#             name='Cluster ID: ' + str(lbls[i]),#             mode='markers',#             hoverinfo='text',#             marker=Marker(#                 showscale=True,#                 colorscale='YIGnBu',#                 reversescale=True,#                 color=[],#                 size=[],#                 colorbar=dict(#                     thickness=15,#                     title='Node Connections',#                     xanchor='left',#                     titleside='right'#                 ),#                 line=dict(width=2))))##     for i in range(len(coords)):#         x, y = coords[i, :]#         lbl = lbls[i]#         size = sizes[i]#         grp = np.where(lbl_set == lbl)[0][0]#         node_traces[grp]['x'].append(x)#         node_traces[grp]['y'].append(y)##         node_traces[grp]['marker']['color'].append(lbl)#         node_traces[grp]['marker']['size'].append(size)#         node_info = 'cluster ID: ' + str(lbl)#         node_traces[grp]['text'].append(node_info)##     fig = Figure(data=Data([edge_trace, node_traces]),#                  layout=Layout(#                      title=title,#                      titlefont=dict(size=16),#                      showlegend=False,#                      hovermode='closest',#                      margin=dict(b=20, l=5, r=5, t=40),#                      annotations=[dict(#                          text=annot,#                          showarrow=False,#                          xref="paper", yref="paper",#                          x=0.005, y=-0.002)],#                      xaxis=XAxis(showgrid=False, zeroline=False, showticklabels=False),#                      yaxis=YAxis(showgrid=False, zeroline=False, showticklabels=False)))##     py.iplot(fig, filename='kdigo_7dayICU')# %%Plot histogram from data in file fdef hist(f, fig_name, title, op=None, bins=50, skip_row=False, skip_col=True, x_lbl='', y_lbl='',         x_rng=None, y_rng=None):    res = []    if skip_row:        _ = f.readline()    for l in f:        if skip_col:            data = np.array(l.strip().split(',')[1:], dtype=float)        else:            data = np.array(l.strip().split(','), dtype=float)        if op == 'count':            count = np.where(data == 1)[0]            data = len(count)        res.append(data)    try:        res = np.array(res)    except:        res = np.concatenate(res)    plt.figure()    plt.hist(res, bins=bins)    plt.xlim(x_rng)    plt.ylim(y_rng)    plt.xlabel(x_lbl)    plt.ylabel(y_lbl)    plt.title(title)    plt.savefig(fig_name)# %%Generate line plot for data in file f corresponding to the patients with their id in the listdef multi_plot(fname, ids, title, out_path, x_lbl='', y_lbl='', x_rng=None, y_rng=None, x_res=1):    f = open(fname, 'r')    # ids = [20236, 53596, 17370, 71346, 2106, 54290]    for line in f:        l = line.rstrip().split(',')        idx = int(l[0])        if idx not in ids:            continue        vec = np.array(l[1:], dtype=float)        t = np.zeros(len(vec))        for i in range(1, len(vec)):            t[i] += (t[i - 1] + float(x_res))        plot(t, vec, out_path, x_lbl, y_lbl, x_rng, y_rng)    f.close()# Single line plotdef plot(x, y, idx, title, path, x_lbl='', y_lbl='', x_rng=None, y_rng=None):    plt.figure()    plt.title(title + ' - ' + str(idx))    plt.plot(x, y)    plt.xlim(x_rng)    plt.ylim(y_rng)    plt.xlabel(x_lbl)    plt.ylabel(y_lbl)    plt.savefig(path + title + '-' + str(idx) + '.pdf')    plt.clf()def stacked_bar(summary_file, ylim=None, loc=None, fname='', title='', fontsize=12, cmap=None, label=None, o=None):    data = np.loadtxt(summary_file, delimiter=',', skiprows=1, dtype=str)    cluster_names = data[:, 0]    f = open(summary_file, 'r')    f.seek(0)    h = np.array(f.readline().rstrip().split(','))    mort_idx = np.where(h == 'pct_inp_mort')[0][0]    n_clust = data.shape[0]    k0_idx = np.where(h == 'kdigo_1')[0][0]    kdigo_data = data[:, k0_idx:k0_idx+4].astype(int)    mort = data[:, mort_idx].astype(float)    plot_data = np.zeros(kdigo_data.shape)    for i in range(n_clust):        height = mort[i]        plot_data[i, 0] = (float(kdigo_data[i, 0]) / np.sum(kdigo_data[i, :])) * height        for j in range(1, 4):            plot_data[i, j] = plot_data[i, j-1] + ((float(kdigo_data[i, j]) / np.sum(kdigo_data[i, :])) * height)    if o is None:        o = np.argsort(mort)    else:        ol = o        o = np.zeros(n_clust, dtype=int)        for i in range(n_clust):            o[i] = np.where(cluster_names == ol[i])[0]    plt.figure()    plt.rc('font', size=fontsize)    ax = plt.subplot(111)    if cmap is None:        b = plt.bar(range(1, n_clust + 1), plot_data[:, 3][o], label='KDIGO 3D', color='red', align='center')        plt.bar(range(1, n_clust + 1), plot_data[:, 2][o], label='KDIGO 3', color='yellow', align='center')        plt.bar(range(1, n_clust + 1), plot_data[:, 1][o], label='KDIGO 2', color='blue', align='center')        plt.bar(range(1, n_clust + 1), plot_data[:, 0][o], label='KDIGO 1', color='green', align='center')    else:        cmap = plt.cm.get_cmap(cmap)        b = plt.bar(range(1, n_clust + 1), plot_data[:, 3][o], label='KDIGO 3D', align='center', color=cmap(0. / (5 - 1)))        plt.bar(range(1, n_clust + 1), plot_data[:, 2][o], label='KDIGO 3', align='center', color=cmap(1. / (5 - 1)))        plt.bar(range(1, n_clust + 1), plot_data[:, 1][o], label='KDIGO 2', align='center', color=cmap(2. / (5 - 1)))        plt.bar(range(1, n_clust + 1), plot_data[:, 0][o], label='KDIGO 1', align='center', color=cmap(3. / (5 - 1)))    plt.ylabel('Hospital Mortality (%)')    plt.xlabel('AKI Subtypes')    plt.xticks(range(1, n_clust+1), cluster_names[o], rotation=30)    if label is not None:        lbl_idx = np.where(h == label)[0][0]        lbls = data[:, lbl_idx].astype(float)        autolabel(ax, b, lbls)    if loc is None:        plt.legend()    else:        plt.legend(loc=loc)    if ylim is None:        top = np.max(plot_data)        ylim = top * 1.2    plt.ylim((0, ylim))    plt.title(title)    plt.tight_layout()    if fname is not '':        plt.savefig(fname, dpi=600)    else:        plt.show()'''def stacked_bar(data_file, primary_idx=0, secondary_idx=3, dt=int, primary_labels=[],                secondary_labels=[], sort=0, fname='', ylim=14):    data = np.loadtxt(data_file, delimiter=',', dtype=dt, skiprows=1)    data1 = data[:, primary_idx]    data2 = data[:, secondary_idx]    lbls1 = np.unique(data1)    lbls2 = np.unique(data2)    n_labels = len(lbls1)    n_labels2 = len(lbls2)    data_dist = np.ones((n_labels, n_labels2))    for i in range(n_labels):        for j in range(n_labels2):            data_dist[i, j] = float(len(np.where(data[np.where(data[:, primary_idx] == lbls1[i])[0], \                                                      secondary_idx] == lbls2[j])[0])) \                              / len(np.where(data[:, primary_idx] == lbls1[i])[0])    counts = np.zeros(n_labels)    for i in range(n_labels):        counts[i] = len(np.where(data1 == lbls1[i])[0])    plot_data = np.zeros((n_labels, n_labels2))    for i in range(n_labels):        plot_data[i, :] = data_dist[i, :] * counts[i]    for i in range(1, n_labels2):        plot_data[:, i] += plot_data[:, i - 1]    plt.figure()    cct = float(counts) / 1000    cm = data_dist[:, 1]    cml = cm * 100    cnm = labels    if sort == 0:        o = np.argsort(cm)        cnm = cnm[o]        cm = cm[o]        cct = cct[o]        cml = cml[o]    else:        o = np.argsort(cct)[::-1]        cnm = cnm[o]        cm = cm[o]        cct = cct[o]        cml = cml[o]    plt.clf()    plt.rc('font', size=15)    ax = plt.subplot(111)    b = plt.bar(range(1, n_labels + 1), cct, label='Deceased at Discharge', color='red')    plt.bar(range(1, n_labels+1), cct * (1 - cm), label='Alive at Discharge', color='blue')    plt.xticks(range(1, n_labels+1), cnm, rotation=30)    plt.ylabel('Number of Patients (x1000)')    autolabel(ax, b, cml)    plt.legend(loc='upper right')    plt.ylim((0, ylim))    plt.tight_layout()    if fname is not '':        plt.savefig(fname)    else:        plt.show()'''def scatter(coords, lbls, figname):    fig = plt.figure()    if coords.shape[1] == 3:        ax = fig.add_subplot(111, projection='3d')        ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], c=lbls)    elif coords.shape[1] == 2:        ax = plt.subplot(111)        ax.scatter(coords[:, 0], coords[:, 1], c=lbls)    plt.savefig(figname)    returndef autolabel(ax, rects, lbls):    """    Attach a text label above each bar displaying its height    """    for rect, lbl in zip(rects, lbls):        height = rect.get_height()        ax.text(rect.get_x() + rect.get_width()/2., 1.05*height,                '%.1f%%' % lbl,                ha='center', va='bottom', fontsize=15)# , rotation=30)def plot_feature_selection(h5_f, lbls, feats, all_names, lbl_name='died_inp',                           method='linear', parameters=[0.1, ], outpath=''):    if type(h5_f) == str:        f = h5py.File(h5_f, 'r')    else:        f = h5_f    o = np.argsort(lbls)    X = feats[o]    lbls = lbls[o]    y = f['meta'][lbl_name][:][o]    cluster_names = np.unique(lbls)    tmax = 0    yticks = []    for i in range(len(cluster_names)):        idx = np.where(lbls == cluster_names[i])[0]        yticks.append(tmax + (len(idx) / 2))        tmax += len(idx)    model, sel = feature_selection(X, y, method=method, params=parameters)    sel_names = all_names[model.get_support()]    plt.rcParams['xtick.bottom'] = plt.rcParams['xtick.labelbottom'] = False    plt.rcParams['xtick.top'] = plt.rcParams['xtick.labeltop'] = True    fig, ax = plt.subplots()    ax.pcolor(sel)    plt.xlim([0, sel.shape[1]])    plt.ylim([0, sel.shape[0]])    ax.set_xticks(np.arange(sel.shape[1]) + 0.5, minor=False)    ax.set_xticklabels(sel_names, rotation=90)    ax.set_yticks(yticks, minor=False)    ax.set_yticklabels(cluster_names)    plt.tight_layout()    if method == 'linear' or method == 'univariate':        plt.savefig(outpath + '%s_%.0E.png' % (method, parameters[0]))    else:        plt.savefig(outpath + '%s.png' % method)    plt.close('all')    plt.rcParams['xtick.bottom'] = plt.rcParams['xtick.labelbottom'] = True    plt.rcParams['xtick.top'] = plt.rcParams['xtick.labeltop'] = False    # for i in range(len(cluster_names)):    #     idx = np.where(lbls == cluster_names[i])[0]    #     fig, ax = plt.subplots()    #     plt.rcParams['xtick.bottom'] = plt.rcParams['xtick.labelbottom'] = False    #     plt.rcParams['xtick.top'] = plt.rcParams['xtick.labeltop'] = True    #    #     ax.pcolor(sel[idx, :])    #     plt.xlim([-1, sel.shape[1] + 1])    #     plt.ylim([-1, len(idx) + 1])    #    #     ax.set_xticks(np.arange(sel.shape[1]) + 0.5, minor=False)    #     ax.set_xticklabels(sel_names, rotation=60)    #    #     ax.set_yticks([])    #    #     plt.savefig(outpath + 'feat_sel_all_%s.png' % cluster_names[i])    #     plt.close(fig)    return model, seldef get_feature_names(feature_file_path):    with open(feature_file_path + 'trajectory_individual/descriptive_features.csv', 'r') as f:        desc_names = np.array(f.readline().rstrip().split(',')[1:], dtype=str)    with open(feature_file_path + 'trajectory_individual/template_features.csv', 'r') as f:        temp_names = np.array(f.readline().rstrip().split(',')[1:], dtype=str)    with open(feature_file_path + 'trajectory_individual/slope_features.csv', 'r') as f:        slope_names = np.array(f.readline().rstrip().split(',')[1:], dtype=str)    feature_names = {}    trajectory_names = np.concatenate((desc_names, temp_names, slope_names))    sofa_names = np.array(['sofa_%d' % x for x in range(6)], dtype=str)    apache_names = np.array(['apache_%d' % x for x in range(13)], dtype=str)    all_clinical_names = np.concatenate((sofa_names, apache_names))    everything_names = np.concatenate((all_clinical_names, trajectory_names))    feature_names['apache_norm'] = apache_names    feature_names['sofa_norm'] = sofa_names    feature_names['all_clinical'] = all_clinical_names    feature_names['all_trajectory_clusters'] = trajectory_names    feature_names['everything_clusters'] = everything_names    return feature_namesdef plot_pairwise_stats(datapath, mortality):    feats = {'admit': 'admit_scr.npy',    'Age': 'age.npy',    'APACHE': 'apache.npy',    'BMI': 'bmi.npy',    'Baseline GFR': 'bsln_gfr.npy',    'Baseline SCr': 'bsln_scr.npy',    'Charlson Score': 'charlson.npy',    'CRRT Days': 'crrt_days.npy',    'Elixhauser Score': 'elixhauser.npy',    'Gross Fluid': 'gross_fluid.npy',    'HD Days': 'hd_days.npy',    'Hospital Free Days': 'hosp_free.npy',    'ICU Free Days': 'icu_free.npy',    'Mech Vent Free Days': 'mv_free.npy',    'Net Fluid': 'net_fluid.npy',    'Peak SCr': 'peak_scr.npy',    'SOFA': 'sofa.npy'}    o = np.argsort(mortality)    for feat in list(feats):        condensed = np.load(datapath + feats[feat][1])